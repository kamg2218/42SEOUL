node*		malloc(){
void		add_back(const T& value){
list() : sz(0), head(0), tail(0) {
list(const list& other) { *this = other; }
list&	operator=(list const &lst) {
explicit list(const Allocator& alloc) : sz(0), head(0), tail(0) { 
explicit list(size_type count, const T& value = T(), const Allocator& alloc = Allocator()) : sz(0), head(0), tail(0) {
template<class InputIt>
list(InputIt first, InputIt last, const Allocator& alloc = Allocator()) : sz(0), head(0), tail(0) {
template<>
list(iterator first, iterator last, const Allocator& alloc) : sz(0), head(0), tail(0) {
template<>
list(T* first, T* last, const Allocator& alloc) : sz(0), head(0), tail(0) {
~list() {
void	assign(size_type count, const T& value){
template<class InputIt>
void	assign(InputIt first, InputIt last){
template<>
void	assign(iterator first, iterator last){
template<>
void	assign(T* first, T* last){
allocator_type	get_allocator() const { allocator_type alloc; return alloc; }
iterator			begin() { return iterator(head->next); }
const_iterator		begin() const { return const_iterator(head->next); }
iterator			end() { return iterator(tail); }
const_iterator		end() const { return const_iterator(tail); }
reverse_iterator		rbegin() { return reverse_iterator(tail->prev); }
const_reverse_iterator	rbegin() const { return const_reverse_iterator(tail->prev); }
reverse_iterator		rend() { return reverse_iterator(head); }
const_reverse_iterator	rend() const { return const_reverse_iterator(head); }
reference	front() { return *(begin()); }
const_reference	front() const { return *(begin()); }
reference	back() { return tail->prev->value; } //if (sz > 0) return *(tail->prev->value); else return *(end()); }
const_reference	back() const { if (sz > 0) return tail->prev->value; else return *(end()); }
		
bool		empty() const { if (begin() == end()) return true; else return false;}
size_type	size() const { return sz; } //std::distance(begin(), end())
size_type	max_size() const { return std::numeric_limits<difference_type>::max(); }

//modifiers
void		clear(){
void		push_front(const T& value){
void		pop_front(){
void		push_back(const T& value){
void		pop_back(){
iterator	insert(iterator pos, const T& value){
void		insert(iterator pos, size_type count, const T& value){
template<class InputIt>
void		insert(iterator pos, InputIt first, InputIt last){
template<>
void		insert(iterator pos, iterator first, iterator last){
iterator	erase(iterator pos){
iterator	erase(iterator first, iterator last){
void		resize(size_type count, T value = T()){
void		swap(list& other){
void		move_node(node* src, node* dst){
void		sort(){
template<class Compare>
void		sort(Compare cmp){
void		merge(list& other){
template <class Compare>
void		merge(list& other, Compare comp){
void		splice(const_iterator pos, list& other){
void		splice(const_iterator pos, list& other, const_iterator it){
void		splice(const_iterator pos, list& other, const_iterator first, const_iterator last){
void		remove(const T& value){
template<class UnaryPredicate>
void		remove_if(UnaryPredicate p){
void		reverse(){
void		unique(){
template<class BinaryPredicate>
void		unique(BinaryPredicate p){
